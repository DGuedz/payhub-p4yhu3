Excelente\! A próxima fase é transformar essa lógica de backend em uma experiência de usuário (UX) de alta qualidade, utilizando o **RainbowKit** para conexão de carteiras.

Como a XRPL é uma *ledger* diferente (não-EVM nativa), o RainbowKit/Wagmi (que são primariamente focados em EVM) não a suportam diretamente. No entanto, o **WalletConnect** (que o RainbowKit usa por baixo dos panos) **suporta XRPL**.

Para o seu hackathon, o ideal é usar o RainbowKit para a parte EVM (que é o que a maioria das carteiras suporta e o que oferece a melhor UX) e, em paralelo, usar o **`xrpl.js`** com uma biblioteca como **`@xrpl-wallet-adapter/walletconnect`** ou similar (como o resultado da pesquisa sugere) para a parte nativa XRPL, ou focar em uma *Wallet* que suporte a XRPL EVM Sidechain (se for o caso) para simplificar a integração.

Vamos focar na **página base usando o RainbowKit + Wagmi** (que você já tem as instruções nos anexos) e adicionar um componente de teste de transação.

-----

## Estrutura da Página Base do PAYHUB (Frontend)

O projeto será construído com React/Vite, conforme suas instruções.

### 1\. Setup do Projeto (Revisão)

Seu frontend deve seguir o fluxo:

1.  **Criação:**
    ```bash
    npm create vite@latest rainbowkit-dapp -- --template react-ts
    cd rainbowkit-dapp
    ```
2.  **Instalação das Dependências:**
    ```bash
    # Usando as versões mais recentes (Wagmi v2, Viem, etc.)
    npm install @rainbow-me/rainbowkit wagmi viem@2.x @tanstack/react-query
    ```
3.  **Execução:**
    ```bash
    npm run dev
    ```

### 2\. Configuração (src/wagmi.ts)

Você deve configurar a rede que o RainbowKit irá usar (vamos usar o `mainnet` EVM como exemplo, mas você pode adicionar qualquer EVM chain, como Sepolia ou Goerli, para testes).

```typescript
// src/wagmi.ts

import { getDefaultConfig } from "@rainbow-me/rainbowkit";
import { mainnet, polygon, arbitrum } from "wagmi/chains"; // Exemplo de chains EVM suportadas

// ** IMPORTANTE: Substitua 'SEU_PROJECT_ID_AQUI' pelo seu ID do WalletConnect Cloud **
const projectId = "SEU_PROJECT_ID_AQUI"; 

export const config = getDefaultConfig({
  appName: "P4YHU3 - PAYHUB",
  projectId: projectId,
  chains: [mainnet, polygon, arbitrum], // Escolha suas chains de teste/produção EVM
  // Adicionar o transporte HTTP padrão para todas as chains
  transports: {
    [mainnet.id]: http(),
    [polygon.id]: http(),
    [arbitrum.id]: http(),
  },
});
```

### 3\. Envolvendo a Aplicação (src/main.tsx)

Mantenha o `main.tsx` como está no seu anexo, garantindo que o `WagmiProvider`, `QueryClientProvider` e `RainbowKitProvider` estejam envolvendo o componente `<App />`.

```typescript
// src/main.tsx

import "./index.css";
import "@rainbow-me/rainbowkit/styles.css";
import React from "react";
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import App from "./App.tsx";

// Importações do RainbowKit/Wagmi
import { config } from "./wagmi.ts";
import { WagmiProvider } from "wagmi";
import { RainbowKitProvider } from "@rainbow-me/rainbowkit";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";

const queryClient = new QueryClient();

createRoot(document.getElementById("root")!).render(
  <StrictMode>
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}>
        <RainbowKitProvider>
          <App />
        </RainbowKitProvider>
      </QueryClientProvider>
    </WagmiProvider>
  </StrictMode>
);
```

### 4\. Componente Base (src/App.tsx)

Agora, criaremos um componente que não apenas conecta a carteira, mas também exibe informações e permite testar uma transação básica (simulando um pagamento).

```tsx
// src/App.tsx

import "./App.css";
import { ConnectButton } from "@rainbow-me/rainbowkit";
import { useAccount, useSendTransaction, useBalance } from "wagmi"; // Hooks úteis
import { parseEther } from "viem"; // Ajuda a converter o valor (ex: '0.001' ETH para Wei)

// --- NOVO COMPONENTE PARA TESTE DE TRANSAÇÃO ---
const SendTransactionTest = () => {
  // Hook para obter o endereço da carteira conectada e status
  const { address, isConnected } = useAccount();

  // Hook para obter o saldo da conta (opcional)
  const { data: balanceData } = useBalance({ address: address });

  // Hook para enviar transação
  const { sendTransaction } = useSendTransaction();

  // Simular o envio de um valor pequeno para um endereço de teste
  const handleSendTestPayment = () => {
    if (!isConnected) {
      alert("Por favor, conecte sua carteira primeiro.");
      return;
    }

    // Endereço de Teste EVM (substitua por um de sua preferência)
    const destinationAddress = "0x70997970C51812dc3A01088eA52ea09e2dC8d844"; 
    
    // Valor em ETH (0.001 ETH de teste)
    const amountToSend = '0.001';

    sendTransaction({
      to: destinationAddress,
      value: parseEther(amountToSend), 
    });
  };

  return (
    <div style={{ marginTop: '20px', padding: '20px', border: '1px solid #ccc', borderRadius: '8px' }}>
      <h2>Informações da Carteira Conectada</h2>
      {isConnected ? (
        <div>
          <p>Endereço: **{address}**</p>
          <p>Saldo (ETH): {balanceData?.formatted} {balanceData?.symbol}</p>
          
          <button 
            onClick={handleSendTestPayment} 
            style={{ padding: '10px 20px', marginTop: '15px', backgroundColor: '#6200EE', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer' }}
          >
            Testar Transação (Enviar {0.001} ETH)
          </button>
          <p style={{ marginTop: '10px', fontSize: '12px' }}>*Isto irá disparar uma transação de teste na rede EVM conectada (ex: Mainnet/Sepolia).</p>
        </div>
      ) : (
        <p>Conecte sua carteira para ver as informações e testar transações.</p>
      )}
    </div>
  );
}
// --- FIM DO NOVO COMPONENTE ---


function App() {
  return (
    <div className="App" style={{ textAlign: 'center', padding: '50px' }}>
      <h1>P4YHU3 - PAYHUB: Demo Conexão Web3</h1>
      
      {/* Botão de Conexão do RainbowKit */}
      <ConnectButton />
      
      {/* Teste de Transação (Aparece após a conexão) */}
      <SendTransactionTest />
      
    </div>
  );
}

export default App;
```

### Próximos Passos de Teste:

1.  **Rodar o Projeto:** Execute `npm run dev`.
2.  **Conectar:** Clique no botão **"Connect Wallet"** e selecione sua carteira (ex: MetaMask ou Rainbow).
3.  **Testar:** Após a conexão, clique em **"Testar Transação"**. Isso irá disparar uma pop-up da carteira solicitando a assinatura e envio de uma transação EVM de teste.

Este é um excelente ponto de partida para o frontend. Ele cumpre o requisito de **"Qualidade de Apresentação"** e usa tecnologia de ponta para a conexão Web3\!